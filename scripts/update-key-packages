#!/usr/bin/ruby

require 'dbi'
require 'pp'

log = File.expand_path('../web/key_packages.log', File.dirname(__FILE__))
fd = File::new(log, 'w')
STDOUT.reopen(fd)
STDERR.reopen(fd)

EXC_SRC = [ ]
INC_SRC = [ 'debian-installer', 'piuparts', 'debian-cd', 'debian-installer-netboot-images' ]
POPCON_PERCENT = 5 # x% of submissions must have the package installed
TESTING='jessie'

dbh = DBI::connect('DBI:Pg:dbname=udd;port=5452', 'udd')
sth = dbh.prepare("select max(insts) from popcon")
sth.execute
rows = sth.fetch_all
sth.finish
minpopcon = rows[0][0].to_i * POPCON_PERCENT/100
puts "# Popcon submissions: #{rows[0][0]} -- #{POPCON_PERCENT}% = #{minpopcon}"

srcs = []
puts "# building initial list"
sth = dbh.prepare <<-EOF
select distinct source from sources where release='sid' and (
source in (select source from popcon_src where insts >= #{minpopcon})
or source in (select source from packages where release='sid' and priority in ('standard', 'important', 'required'))
or source in (select source from packages where section='debian-installer' and release='sid')
);
EOF
sth.execute
rows = sth.fetch_all
srcs = rows.map { |r| r[0] } + INC_SRC - EXC_SRC
sth.finish

puts "# Initial list: #{srcs.sort.join(' ')}"
puts "# Now recursively getting build-depends..."
round = 1
begin
  puts "# Round #{round}, #srcs = #{srcs.length}"
  round += 1
  puts "# Getting build-depends for sources"
  sth = dbh.prepare("select distinct build_depends from sources where release='sid' and source in ('#{srcs.join('\', \'')}')")
  sth.execute
  rows = sth.fetch_all - [nil]
  rows -= [nil]
  bdeps = []
  rows.each do |r|
    next if r == [nil]
    bdeps += r[0].split(/\s*[|,]\s*/).map { |e| e.gsub(/( |\(|\[).*/, '') }
  end
  bdeps.uniq!
  puts "# Getting sources for build-depends"
  sth = dbh.prepare("select distinct source from packages where package in ('#{bdeps.join('\', \'')}')")
  sth.execute
  bdep_srcs = sth.fetch_all.map { |r| r[0] }
  newsrcs = bdep_srcs - srcs
  srcs += bdep_srcs
  srcs.uniq!
  srcs -= EXC_SRC
  puts "# Adding #{newsrcs.length} source packages: #{newsrcs.sort.join(" ")}"
end until newsrcs.empty?

puts "# Final list of #{srcs.length} key source packages:"
puts srcs.sort.join(" ")

# Cleanup
dbh.do <<EOF
DELETE FROM key_packages;
EOF

sth = dbh.prepare("INSERT INTO key_packages(source) VALUES(?)")
srcs.sort.each do |src|
  sth.execute(src)
end

dbh.do("ANALYZE key_packages")
